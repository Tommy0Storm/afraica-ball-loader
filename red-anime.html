<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dynamic Random Paths • Red Blinkers (different speeds)</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #hud{position:fixed;right:10px;bottom:10px;color:#666;font:11px/1.2 system-ui,Arial}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">dynamic morphing paths • multiple wave speeds • additive glow</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  const canvas   = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:false, powerPreference:'high-performance'});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);

  const scene  = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1,1,1,-1,-1,1); // screen-space

  // ---------- soft red sprite texture ----------
  function makeDotTexture(size=64){
    const cnv=document.createElement('canvas'); cnv.width=cnv.height=size;
    const g=cnv.getContext('2d'); const r=size*0.46;
    const grd=g.createRadialGradient(size/2,size/2,0,size/2,size/2,r);
    grd.addColorStop(0.00,'rgba(255,0,0,1)');
    grd.addColorStop(0.35,'rgba(255,0,0,0.7)');
    grd.addColorStop(1.00,'rgba(255,0,0,0)');
    g.fillStyle=grd; g.beginPath(); g.arc(size/2,size/2,r,0,Math.PI*2); g.fill();
    return new THREE.CanvasTexture(cnv);
  }
  const dotTex = makeDotTexture();

  // ============ TWEAKS WITH TRAILS ============
  const COUNT        = 15000;   // total lights (increased for trails)
  const STRANDS      = 8;      // more morphing paths
  const SAMPLES      = 200;   // polyline samples per strand (higher = smoother)
  const JITTER       = 0.15;  // more perpendicular jitter
  const BASE_ALPHA   = 0.12;   // higher base visibility
  const BLINK_WIDTH  = 0.15;   // wider blink window
  const SIZE_MIN     = 0.003;  // smaller particles
  const SIZE_MAX     = 0.018;  // larger max size
  const TRAIL_LENGTH = 12;     // particle trail length
  const TRAIL_FADE   = 0.85;   // trail fade factor

  // travelling wave heads with different speeds (cycles/second)
  const HEADS = [
    { speed: 0.009, phase: 0.10 },
    { speed: 0.104, phase: 0.33 },
    { speed: 0.0109, phase: 0.67 }
  ];
  // set some go leftwards
  HEADS.forEach((h,i)=>{ if(i%2) h.speed*=-1; });

  // ---------- periodic “noise” helpers (looping) ----------
  // We build a looping function: sum of sines with different frequencies that
  // depends on x and time t, both periodic. This gives a random-ish but seamless motion.
  function rand(seed){ return Math.sin(seed*127.1)*43758.5453 % 1; }
  const harmonics = Array.from({length:5}, (_,i)=>({
    kx: 0.6 + i*0.45,     // spatial frequency
    kt: 0.1 + i*0.21,     // temporal frequency
    ax: 0.06 * (0.9**i),  // amplitude scaling
    ph: Math.random()*Math.PI*2
  }));
  function loopNoise(x, t, baseAmp=0.28, vshift=0){
    // x in [-1,1], t in seconds. Returns y in [-amp, amp] with slow morphing.
    let y = 0;
    for(const h of harmonics){
      y += h.ax * Math.sin(x * Math.PI * 2 * h.kx + t * h.kt + h.ph);
    }
    return vshift + baseAmp * y;
  }

  // ---------- build & sample polyline with arc-length ----------
  function buildPolyline(samples, amp, t, vshift){
    const pts = [];
    const x0=-0.92, x1=0.92;
    for(let i=0;i<=samples;i++){
      const u = i/samples;
      const x = THREE.MathUtils.lerp(x0,x1,u);
      const y = loopNoise(x, t, amp, vshift);
      pts.push(new THREE.Vector2(x,y));
    }
    const s=[0]; let acc=0;
    for(let i=1;i<pts.length;i++){ acc += pts[i].distanceTo(pts[i-1]); s.push(acc); }
    for(let i=0;i<s.length;i++) s[i] /= acc || 1e-6; // normalize
    return {pts, s};
  }
  function samplePolyline(poly, t){ // t in [0,1]
    const s=poly.s, pts=poly.pts;
    let lo=0, hi=s.length-1;
    while(hi-lo>1){ const mid=(lo+hi)>>1; (s[mid] < t) ? (lo=mid) : (hi=mid); }
    const span=(s[hi]-s[lo])||1e-6; const a=(t-s[lo])/span;
    const p0=pts[lo], p1=pts[hi];
    return new THREE.Vector2(
      THREE.MathUtils.lerp(p0.x,p1.x,a),
      THREE.MathUtils.lerp(p0.y,p1.y,a)
    );
  }

  // ---------- initial strands (placeholders; rebuilt each frame) ----------
  let strands = [];
  function rebuildStrands(time){
    strands = [];
    for(let i=0;i<STRANDS;i++){
      const vshift = (i-(STRANDS-1)/2)*0.20;      // vertical spread
      strands.push(buildPolyline(SAMPLES, 3.0, time*0.5 + i*1.7, vshift));
    }
  }
  rebuildStrands(0);

  // ---------- allocate points with trail system ----------
  const positions = new Float32Array(COUNT*3);
  const phases    = new Float32Array(COUNT);  // where on arc 0..1
  const sizes     = new Float32Array(COUNT);
  const strandIdx = new Uint16Array(COUNT);   // which strand
  const trailIntensity = new Float32Array(COUNT); // trail fade factor

  // Particle trail history
  const particleTrails = Array.from({length:COUNT}, () => []);

  for(let i=0;i<COUNT;i++){
    const s = Math.floor(Math.random()*STRANDS);
    const t = Math.random();
    const j = (Math.random()-0.5)*2*JITTER;   // perpendicular jitter magnitude
    // set temp; positions will be updated in animate()
    positions[i*3+0]=0; positions[i*3+1]=0; positions[i*3+2]=0;
    phases[i]=t; sizes[i]=THREE.MathUtils.lerp(SIZE_MIN,SIZE_MAX,Math.random()**3);
    strandIdx[i]=s;
    trailIntensity[i] = 1.0; // full intensity by default
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geo.setAttribute('aSize',    new THREE.BufferAttribute(sizes,1));
  geo.setAttribute('aPhase',   new THREE.BufferAttribute(phases,1));
  geo.setAttribute('aTrailIntensity', new THREE.BufferAttribute(trailIntensity,1));

  // save jitters separately (JS side), apply each frame using normals
  const jitters = Array.from({length:COUNT}, ()=> (Math.random()-0.5)*2*JITTER);

  const mat = new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
    uniforms:{
      uTex:{value:dotTex},
      uTime:{value:0},
      uBaseAlpha:{value:BASE_ALPHA},
      uBlinkWidth:{value:BLINK_WIDTH},
      uHeadCount:{value:HEADS.length},
      uHeadSpeeds:{value:new THREE.Vector4(
        HEADS[0]?.speed||0, HEADS[1]?.speed||0, HEADS[2]?.speed||0, HEADS[3]?.speed||0
      )},
      uHeadPhases:{value:new THREE.Vector4(
        HEADS[0]?.phase||0, HEADS[1]?.phase||0, HEADS[2]?.phase||0, HEADS[3]?.phase||0
      )}
    },
    vertexShader:/* glsl */`
      attribute float aSize;
      attribute float aTrailIntensity;
      varying vec2 vPt;
      varying float vPhase;
      varying float vTrailIntensity;
      void main(){
        vPhase = position.z;    // we'll stash phase in .z (set in JS each frame)
        vPt    = position.xy;   // for debugging if needed
        vTrailIntensity = aTrailIntensity; // pass trail intensity to fragment
        gl_Position = vec4(position.xy, 0.0, 1.0);
        float ndcToPx = 0.5 * float(${innerHeight}.0);
        gl_PointSize = aSize * ndcToPx * (0.5 + aTrailIntensity * 0.5); // size based on trail intensity
      }
    `,
    fragmentShader:/* glsl */`
      precision highp float;
      uniform sampler2D uTex;
      uniform float uTime, uBaseAlpha, uBlinkWidth;
      uniform int   uHeadCount;
      uniform vec4  uHeadSpeeds;
      uniform vec4  uHeadPhases;
      varying float vPhase;
      varying float vTrailIntensity;

      float head(float t, float speed, float phase){
        // t in seconds → wrap 0..1
        float h = fract(t * speed + phase);
        // allow negative speed (leftward)
        return (h < 0.0) ? (h + 1.0) : h;
      }

      void main(){
        vec2 uv = gl_PointCoord;
        vec4 tex = texture2D(uTex, uv);
        float glow = 0.0;
        for(int i=0;i<4;i++){
          if(i>=uHeadCount) break;
          float sp = (i==0)? uHeadSpeeds.x : (i==1)? uHeadSpeeds.y : (i==2)? uHeadSpeeds.z : uHeadSpeeds.w;
          float ph = (i==0)? uHeadPhases.x : (i==1)? uHeadPhases.y : (i==2)? uHeadPhases.z : uHeadPhases.w;
          float h  = head(uTime, sp, ph);
          float d  = abs(vPhase - h); d = min(d, 1.0 - d); // wrapped distance
          float w  = max(0.0, 1.0 - d / uBlinkWidth);
          glow    += pow(sin(w*1.5707963), 5.0);
        }

        // Enhanced trail effects
        float trailGlow = vTrailIntensity * (0.3 + glow * 0.7);
        float totalGlow = glow + trailGlow;
        float a = (uBaseAlpha * vTrailIntensity) + totalGlow * 0.9;

        // More vibrant red colors with trail variations
        vec3 baseRed = vec3(1.0, 0.0, 0.0);
        vec3 brightRed = vec3(1.0, 0.3, 0.1);
        vec3 c = mix(baseRed, brightRed, vTrailIntensity) * (0.35 + totalGlow * 1.8);

        // Add particle trail streaking effect
        float streakEffect = pow(vTrailIntensity, 0.5) * (1.0 + sin(uTime * 20.0 + vPhase * 10.0) * 0.2);
        c *= streakEffect;

        vec4 col = vec4(c, a) * tex;
        if(col.a < 0.01) discard;
        gl_FragColor = col;
      }
    `
  });

  const points = new THREE.Points(geo, mat);
  scene.add(points);

  // ---------- animate ----------
  function updatePositions(time){
    // rebuild each strand's polyline (morphs over time)
    rebuildStrands(time);

    // for each dot: sample strand at phase, compute tiny normal, apply jitter, and
    // stuff its arc-phase into position.z (so shader can read it for blinking).
    const pos = geo.getAttribute('position');
    const pha = geo.getAttribute('aPhase');
    const trailIntensityAttr = geo.getAttribute('aTrailIntensity');

    for(let i=0;i<COUNT;i++){
      const sIdx = strandIdx[i];
      const t    = pha.getX(i);
      const poly = strands[sIdx];
      const p    = samplePolyline(poly, t);

      // Store current position in trail history
      const currentPos = {x: p.x, y: p.y, time: time};
      particleTrails[i].push(currentPos);

      // Keep only recent trail positions
      if(particleTrails[i].length > TRAIL_LENGTH) {
        particleTrails[i].shift();
      }

      // Calculate trail intensity based on movement speed
      let intensity = 1.0;
      if(particleTrails[i].length > 1) {
        const prev = particleTrails[i][particleTrails[i].length - 2];
        const distance = Math.hypot(p.x - prev.x, p.y - prev.y);
        intensity = Math.min(1.0, distance * 50.0); // Scale movement to intensity
      }

      // Update trail intensity with fade
      trailIntensityAttr.setX(i, intensity * TRAIL_FADE + 0.15);

      // tiny normal from nearby arc sample
      const t2 = Math.min(1, t + 0.001);
      const p2 = samplePolyline(poly, t2);
      const tx = p2.x - p.x, ty = p2.y - p.y;
      const len= Math.hypot(tx,ty)||1;
      const nx = -ty/len, ny = tx/len;

      const j  = jitters[i];
      const x  = p.x + nx*j;
      const y  = p.y + ny*j;

      pos.setXYZ(i, x, y, t); // stash phase in Z
    }
    pos.needsUpdate = true;
    trailIntensityAttr.needsUpdate = true;
  }

  function render(tms){
    const t = tms*0.001;
    updatePositions(t);
    mat.uniforms.uTime.value = t;
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  addEventListener('resize', () => {
    renderer.setSize(innerWidth, innerHeight);
  });
})();
</script>
</body>
</html>
